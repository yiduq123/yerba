getgenv().Mooze = {
    Global = {
        Enabled = true, 
        Keybind = "C" -- aimbot shit
    },
    ["Trigger Bot"] = {
        Enabled = true, 
        Activation = {
            ["Activation Bind"] = "X"
        },
        FOV = {
            X = 5
        },
        Prediction = {
            X = 0, 
            Y = 0, 
            Z = 0  
        },
        ["Click Cooldown"] = 0.1, 
        Weapons = { 
            "Revolver",
            "Double Barrel",
            "Tactical SG",
            "Shotgun"
        }
    },
    ["Velocity Calculation"] = {
        Enabled = true,
        Magnitude = 10 
    },
    ["Camera Aimbot"] = {
        Enabled = true, 
        Keybind = "C", -- (overridden by Global.Keybind)
        ["Hit Part"] = "HumanoidRootPart", -- Target part ("HumanoidRootPart" or "Closest Point")
        Prediction = {
            X = 0, 
            Y = 0, 
            Z = 0
        },
        Snappiness = 0.132
    },
    ["Silent Aimbot"] = {
        Enabled = true, 
        ["Hit Part"] = "Closest Point", -- Target part ("Head" or "Closest Point")
        FOV = {
            Enabled = true, 
            Size = {
                X = 15 
            },
            ["Weapons Configuration"] = {
                Enabled = false, 
                Shotguns = {
                    X = 15 
                },
                Pistols = {
                    X = 8 
                }
            }
        },
        Prediction = {
            X = 0, 
            Y = 0, 
            Z = 0  
        },
        ["Closest Point"] = {
            ["Point Scale"] = 1.0 
        },
        ["Client Bullet Redirection"] = {
            Enabled = true, 
            Prediction = {
                X = 0, 
                Y = 0,
                Z = 0  
            },
            Weapons = { 
                "M4A1",
                "AK47"
            }
        }
    },
    ["Movement Modifications"] = {
        ["Slowdown Modifications"] = {
            Enabled = false, 
            Weapons = {
                ["M4A1"] = {
                    Multiplier = 0.1 
                },
                ["AK47"] = {
                    Multiplier = 0.12 
                },
                ["Pistol"] = {
                    Multiplier = 0.08 
                },
                ["Shotgun"] = {
                    Multiplier = 0.15 
                }
            }
        },
        ["Speed Modifications"] = {
            Enabled = false, 
            Normal = {
                Multiplier = 16 
            },
            ["Low Health"] = {
                Multiplier = 12
            },
            Reloading = {
                Multiplier = 10 
            },
            Shooting = {
                Multiplier = 14 
            }
        }
    },
    ["Weapon Modifications"] = {
        ["Spread Modifications"] = {
            Enabled = false,
            M4A1 = {
                Multiplier = 0.5 
            },
            AK47 = {
                Multiplier = 0.7 
            },
            Pistol = {
                Multiplier = 0.4 
            },
            Shotgun = {
                Multiplier = 0.8 
            }
        }
    }
}

-- if not getgenv().directory then
--     game.Players.LocalPlayer:Kick("Script directory was not found!\nNOTE: THE SERVER MAY BE DOWN \nplease dm 1catlol if you have entered yours correctly")
--     wait(3)
--     game.Players.LocalPlayer:Destroy()
--     return LPH_CRASH()
-- end

-- hookfunction security
    local exe_name, exe_version = identifyexecutor()
    local function home999() end
    local function home888() end

    if exe_name ~= "Wave Windows" then
        hookfunction(home888, home999)
        if isfunctionhooked(home888) == false then
            game.Players.LocalPlayer:Destroy()
            return LPH_CRASH()
        end
    end 
    
    local function check_env(env)
        for _, func in env do
            if type(func) ~= "function" then
                continue
            end

            local functionhook = isfunctionhooked(func)

            if functionhook then
                game.Players.LocalPlayer:Destroy()
                return LPH_CRASH()
            end
        end
    end

    check_env( getgenv() )
    check_env( getrenv() )
--

local Lua_Fetch_Connections = getconnections
local Lua_Fetch_Upvalues = getupvalues
local Lua_Hook = hookfunction 
local Lua_Hook_Method = hookmetamethod
local Lua_Unhook = restorefunction
local Lua_Replace_Function = replaceclosure
local Lua_Set_Upvalue = setupvalue
local Lua_Clone_Function = clonefunction

local Game_RunService = game:GetService("RunService")
local Game_LogService = game:GetService("LogService")
local Game_LogService_MessageOut = Game_LogService.MessageOut

local String_Lower = string.lower
local Table_Find = table.find
local Get_Type = type

local Current_Connections = {};
local Hooked_Connections = {};

local function Test_Table(Table, Return_Type)
    for TABLE_INDEX, TABLE_VALUE in Table do
        if type(TABLE_VALUE) == String_Lower(Return_Type) then
            return TABLE_VALUE, TABLE_INDEX
        end

        continue
    end
end

local function Print_Table(Table)
    table.foreach(Table, print)
end

if getgenv().DEBUG then
    print("[auth.injected.live] Waiting...")
end

local good_check = 0

function auth_heart()
    -- local avalible = pcall(function() return loadstring(game:HttpGet("https://auth.injected.live/" .. directory))() end)
    
    -- if (not avalible or not game:HttpGet("https://auth.injected.live/" .. directory)) and good_check <= 0 then
    --     print("error", avalible, game:HttpGet("https://auth.injected.live/" .. directory))
    --     game.Players.LocalPlayer:Destroy()
    --     return LPH_CRASH()
    -- end

    return true , true
end

function Lua_Common_Intercept(old, ...)
    print(...)
    return old(...)
end

function XVNP_L(CONNECTION)
    local s, e = pcall(function()
        local OPENAC_TABLE = Lua_Fetch_Upvalues(CONNECTION.Function)[9]
        local OPENAC_FUNCTION = OPENAC_TABLE[1]
        local IGNORED_INDEX = {3, 12, 1, 11, 15, 8, 20, 18, 22}

        --[[
            3(Getfenv), 1(create thread), 12(Some thread function errors btw), 11( buffer (BANS YOU) ), 8(BXOR), 14(WRAP), 15(YIELD), 22(JUNK), 20(Setfenv), 18(Idk for now)
        ]]


        Lua_Set_Upvalue(OPENAC_FUNCTION, 14, function(...)
            return function(...)
                local args = {...}

                if type(args[1]) == "table" and args[1][1] then
                    pcall(function()
                        if type(args[1][1]) == "userdata" then
                            args[1][1]:Disconnect()
                            args[1][2]:Disconnect()
                            args[1][3]:Disconnect()
                            args[1][4]:Disconnect()
                            --warn("[XVNP] DISCONNECTING CURRENT FUNCTIONS")
                        end

                        --Print_Table(args[1])
                    end)
                end 
            end
        end)

        Lua_Set_Upvalue(OPENAC_FUNCTION, 1, function(...)
            task.wait(200)
        end)

        hookfunction(OPENAC_FUNCTION, function(...)
            --warn("[XVNP DEBUG]", ...)
            return {}
        end)
    end)
end

local XVNP_LASTUPDATE = 0
local XVNP_UPDATEINTERVAL = 5

local XVNP_CONNECTIONSNIFFER;

XVNP_CONNECTIONSNIFFER = Game_RunService.RenderStepped:Connect(function()
    if #Lua_Fetch_Connections(Game_LogService_MessageOut) >= 2 then
        --print("[XVNP] !Emulator overflow!")
        XVNP_CONNECTIONSNIFFER:Disconnect()
    end

    if tick() - XVNP_LASTUPDATE >= XVNP_UPDATEINTERVAL then
        XVNP_LASTUPDATE = tick() 

        local OpenAc_Connections = Lua_Fetch_Connections(Game_LogService_MessageOut)

        for _, CONNECTION in OpenAc_Connections do
            if not table.find(Current_Connections, CONNECTION) then
                table.insert(Current_Connections, CONNECTION)
                table.insert(Hooked_Connections, CONNECTION)

                XVNP_L(CONNECTION)
                
            end
        end
    end
end)

local last_beat = 0
Game_RunService.RenderStepped:Connect(function()
    if last_beat + 1 < tick() then
        last_beat = tick() + 1 

        local what, are = auth_heart()

        if not are or not what then
            if good_check <= 0 then
                game.Players.LocalPlayer:Destroy()
                return LPH_CRASH()
            else
                good_check -=1
            end
        else
            good_check += 1
        end

    end
end)

if getgenv().DEBUG then
    print("[auth.injected.live] Started Emulation Thread")
end


local accessGranted = false
local otherThingLoaded = false

spawn(function()
	wait(1)
	otherThingLoaded = true
end)

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local TitleBar = Instance.new("Frame")
local Icon = Instance.new("ImageLabel")
local TitleText = Instance.new("TextLabel")
local CloseButton = Instance.new("TextButton")
local MinimizeButton = Instance.new("TextButton")
local MaximizeButton = Instance.new("TextButton")
local TextLabel = Instance.new("TextLabel")
local KeyLabel = Instance.new("TextLabel")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local player = game:GetService("Players").LocalPlayer
local Character = player.Character or player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local originalWalkSpeed = Humanoid.WalkSpeed
local originalJumpPower = Humanoid.JumpPower
local correctKey = "123"
local cursorColor = Color3.fromRGB(255, 255, 255)
local typedKeyColor = Color3.fromRGB(128, 128, 128)
local underlineLength = 1
local underlineChar = "▁"
local blinkSpeed = 0.5
local authDelay = 5
local hideDelay = 5
local typedKey = ""
local showUnderline = true
local canType = false
local isAuthenticating = false

ScreenGui.Name = "CST"
ScreenGui.Parent = game.CoreGui

Frame.Name = "MoozeFrame"
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.Size = UDim2.new(0, 600, 0, 300)
Frame.Position = UDim2.new(0.5, -300, 0.5, -150)
Frame.ClipsDescendants = true

TitleBar.Name = "TitleBar"
TitleBar.Parent = Frame
TitleBar.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
TitleBar.BorderSizePixel = 0
TitleBar.Size = UDim2.new(1, 0, 0, 28)
TitleBar.Position = UDim2.new(0, 0, 0, 0)
TitleBar.Active = true

Icon.Name = "TitleIcon"
Icon.Parent = TitleBar
Icon.BackgroundTransparency = 1
Icon.Size = UDim2.new(0, 16, 0, 16)
Icon.Position = UDim2.new(0, 6, 0, 6)
Icon.Image = "rbxassetid://128024012812354"

TitleText.Name = "TitleText"
TitleText.Parent = TitleBar
TitleText.BackgroundTransparency = 1
TitleText.Size = UDim2.new(1, -100, 1, 0)
TitleText.Position = UDim2.new(0, 28, 0, 0)
TitleText.Text = "Mooze"
TitleText.Font = Enum.Font.SourceSans
TitleText.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleText.TextSize = 18
TitleText.TextXAlignment = Enum.TextXAlignment.Left

CloseButton.Name = "CloseButton"
CloseButton.Parent = TitleBar
CloseButton.Size = UDim2.new(0, 40, 0, 28)
CloseButton.Position = UDim2.new(1, -40, 0, 0)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "X"
CloseButton.Font = Enum.Font.SourceSansBold
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 18

MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Parent = TitleBar
MinimizeButton.Size = UDim2.new(0, 40, 0, 28)
MinimizeButton.Position = UDim2.new(1, -120, 0, 0)
MinimizeButton.BackgroundTransparency = 1
MinimizeButton.Text = "-"
MinimizeButton.Font = Enum.Font.SourceSansBold
MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.TextSize = 24

MaximizeButton.Name = "MaximizeButton"
MaximizeButton.Parent = TitleBar
MaximizeButton.Size = UDim2.new(0, 40, 0, 28)
MaximizeButton.Position = UDim2.new(1, -80, 0, 0)
MaximizeButton.BackgroundTransparency = 1
MaximizeButton.Text = "▢"
MaximizeButton.Font = Enum.Font.SourceSansBold
MaximizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MaximizeButton.TextSize = 18
MaximizeButton.Visible = false

local dragging = false
local dragInput, dragStart, startPos
local function update(input)
	local delta = input.Position - dragStart
	Frame.Position = UDim2.new(Frame.Position.X.Scale, startPos.X.Offset + delta.X, Frame.Position.Y.Scale, startPos.Y.Offset + delta.Y)
end
TitleBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = Frame.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)
TitleBar.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		dragInput = input
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if dragging and input == dragInput then
		update(input)
	end
end)
local normalSize = Frame.Size
local normalContentVisible = true
MinimizeButton.MouseButton1Click:Connect(function()
	if normalContentVisible then
		TweenService:Create(Frame, TweenInfo.new(0.2), {Size = UDim2.new(normalSize.X.Scale, normalSize.X.Offset, 0, TitleBar.Size.Y.Offset)}):Play()
		TextLabel.Visible = false
		KeyLabel.Visible = false
		MaximizeButton.Visible = true
		normalContentVisible = false
	end
end)
MaximizeButton.MouseButton1Click:Connect(function()
	if not normalContentVisible then
		TweenService:Create(Frame, TweenInfo.new(0.2), {Size = normalSize}):Play()
		TextLabel.Visible = true
		KeyLabel.Visible = true
		MaximizeButton.Visible = false
		normalContentVisible = true
	end
end)
CloseButton.MouseButton1Click:Connect(function()
	ScreenGui:Destroy()
end)
TextLabel.Name = "MoozeASCII"
TextLabel.Parent = Frame
TextLabel.BackgroundTransparency = 1
TextLabel.Size = UDim2.new(1, 0, 0.8, 0)
TextLabel.Position = UDim2.new(-0.067, 0, -0.1, 0)
TextLabel.Font = Enum.Font.Code
TextLabel.Text = [[
     ooo        ooooo    .oooooo.     .oooooo.     oooooooooooo   oooooooooooo
     `88.       .888'   d8p'  `Y8b   d8p'  `Y8b   d'd888' '888'       `8     
888b     d'888   888      888 888      888        .888P      888
     8 Y88  .P  888   888      888 888      888       d888'       888oooo8
     8  `888'   888   888      888 888      888     .888P         888    "
            8    Y     888   `88b    d88` `88b    d88`    d888'     .P   888       o    
       o8o        o888o    Y8bood8P'    Y8bood8P'   .8888888888P    O888ooooood8
]]
TextLabel.TextColor3 = Color3.fromRGB(128, 128, 128)
TextLabel.TextSize = 13
TextLabel.TextWrapped = true
TextLabel.TextXAlignment = Enum.TextXAlignment.Center
TextLabel.TextYAlignment = Enum.TextYAlignment.Center
KeyLabel.Name = "KeyLabel"
KeyLabel.Parent = Frame
KeyLabel.BackgroundTransparency = 1
KeyLabel.Position = UDim2.new(0, 29, 0, 200)
KeyLabel.Size = UDim2.new(0.7, 0, 0.1, 0)
KeyLabel.Font = Enum.Font.Code
KeyLabel.RichText = true
KeyLabel.TextColor3 = Color3.fromRGB(128, 128, 128)
KeyLabel.TextSize = 12
KeyLabel.TextXAlignment = Enum.TextXAlignment.Left
KeyLabel.TextYAlignment = Enum.TextYAlignment.Center
KeyLabel.Active = true
local function updateKeyLabel()
	if isAuthenticating then return end
	local underline = showUnderline and string.rep(underlineChar, underlineLength) or ""
	KeyLabel.Text = string.format('[<font color="rgb(255,0,0)">—</font>] Key: <font color="rgb(%d,%d,%d)">%s</font><font color="rgb(%d,%d,%d)">%s</font>', typedKeyColor.R*255, typedKeyColor.G*255, typedKeyColor.B*255, typedKey, cursorColor.R*255, cursorColor.G*255, cursorColor.B*255, underline)
end
task.spawn(function()
	while true do
		if not isAuthenticating then
			showUnderline = not showUnderline
			updateKeyLabel()
		end
		wait(blinkSpeed)
	end
end)
local keyMapping = {Zero="0", One="1", Two="2", Three="3", Four="4", Five="5", Six="6", Seven="7", Eight="8", Nine="9", Comma=",", Period=".", Slash="/", BackSlash="\\", Semicolon=";", Quote="'", Minus="-", Equal="=", Grave="`", LeftBracket="[", RightBracket="]", F1="F1", F2="F2", F3="F3", F4="F4", F5="F5", F6="F6", F7="F7", F8="F8", F9="F9", F10="F10", F11="F11", F12="F12", Space=" ", Tab="\t", CapsLock="CapsLock", Insert="Insert", Delete="Delete", Home="Home", End="End", PageUp="PageUp", PageDown="PageDown", Up="↑", Down="↓", Left="←", Right="→"}
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if canType and input.UserInputType == Enum.UserInputType.Keyboard then
		if input.KeyCode == Enum.KeyCode.Return then
			canType = false
			Humanoid.WalkSpeed = originalWalkSpeed
			Humanoid.JumpPower = originalJumpPower
			if typedKey == correctKey then
				isAuthenticating = true
				KeyLabel.Text = '[<font color="rgb(255,0,0)">-</font>] Authenticating...'
				wait(authDelay)
				repeat task.wait() until otherThingLoaded
				KeyLabel.Text = '[<font color="rgb(255,0,0)">-</font>] Hiding console in <font color="rgb(255,0,0)">5.00</font> seconds!'
				wait(hideDelay)
				local function fadeOut(gui, duration)
					for _, object in ipairs(gui:GetDescendants()) do
						if object:IsA("TextLabel") then
							TweenService:Create(object, TweenInfo.new(duration), {TextTransparency = 1}):Play()
						elseif object:IsA("TextButton") then
							TweenService:Create(object, TweenInfo.new(duration), {TextTransparency = 1}):Play()
						elseif object:IsA("ImageLabel") then
							TweenService:Create(object, TweenInfo.new(duration), {ImageTransparency = 1}):Play()
						elseif object:IsA("Frame") then
							TweenService:Create(object, TweenInfo.new(duration), {BackgroundTransparency = 1}):Play()
						end
					end
				end
				fadeOut(ScreenGui, 2)
				wait(2)
				ScreenGui:Destroy()
				accessGranted = true
			else
				player:Kick("Invalid Key")
			end
			updateKeyLabel()
		elseif input.KeyCode == Enum.KeyCode.Backspace then
			typedKey = typedKey:sub(1, -2)
			updateKeyLabel()
		else
			local keyStr = input.KeyCode.Name
			if #keyStr == 1 then
				typedKey = typedKey .. keyStr:lower()
			elseif keyMapping[keyStr] then
				typedKey = typedKey .. keyMapping[keyStr]
			end
			updateKeyLabel()
		end
	end
end)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		local mousePos = input.Position
		local absPos = KeyLabel.AbsolutePosition
		local absSize = KeyLabel.AbsoluteSize
		if mousePos.X >= absPos.X and mousePos.X <= absPos.X + absSize.X and mousePos.Y >= absPos.Y and mousePos.Y <= absPos.Y + absSize.Y then
			canType = true
			typedKey = ""
			updateKeyLabel()
			originalWalkSpeed = Humanoid.WalkSpeed
			originalJumpPower = Humanoid.JumpPower
			Humanoid.WalkSpeed = 0
			Humanoid.JumpPower = 0
		else
			if canType then
				Humanoid.WalkSpeed = originalWalkSpeed
				Humanoid.JumpPower = originalJumpPower
			end
			canType = false
			updateKeyLabel()
		end
	end
end)
updateKeyLabel()
repeat task.wait() until accessGranted


--------------------------------------------------
-- Global Enable Check
--------------------------------------------------
if not getgenv().Mooze or not getgenv().Mooze["Global"] or not getgenv().Mooze["Global"]["Enabled"] then
    return -- Entire script stops running if disabled
end


--------------------------------------------------
-- Trigger Bot Code with Velocity-Based Lead Prediction
--------------------------------------------------
local Players            = game:GetService("Players")
local LocalPlayer        = Players.LocalPlayer
local Camera             = workspace.CurrentCamera
local UserInputService   = game:GetService("UserInputService")
local RunService         = game:GetService("RunService")

-- Cache config
local config             = getgenv().Mooze
local triggerConfig      = config["Trigger Bot"]
local velocityConfig     = config["Velocity Calculation"]

-- Pre‑build your allowed‑parts list
local allowedPartsList = {
    "Head","UpperTorso","HumanoidRootPart","LowerTorso",
    "LeftHand","RightHand","LeftLowerArm","RightLowerArm",
    "LeftUpperArm","RightUpperArm","LeftFoot","LeftLowerLeg",
    "LeftUpperLeg","RightLowerLeg","RightFoot","RightUpperLeg"
}

-- FOV Circle (unchanged)
local Circle = Drawing.new("Circle")
Circle.Visible      = false
Circle.Transparency = 1
Circle.Color       = Color3.new(1,1,1)
Circle.Filled      = true
Circle.Radius      = triggerConfig["FOV"]["X"] * 5
Circle.NumSides    = math.floor(Circle.Radius * 10)
Circle.Position    = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- Simple wall‑check as before
local function WallCheck(part)
    local origin    = Camera.CFrame.Position
    local target    = part.Position
    local dir       = (target - origin).Unit
    local dist      = (target - origin).Magnitude
    local params    = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    local hit = workspace:Raycast(origin, dir * dist, params)
    if hit then
        local mdl = hit.Instance:FindFirstAncestorOfClass("Model")
        return not (mdl and Players:GetPlayerFromCharacter(mdl))
    end
    return false
end

-- Get the closest target inside the circle (throttled)
local scanInterval = 0.033  -- ~30 checks/sec
local timeSinceLast  = scanInterval

local function GetPlayerInCircle()
    local closestDist = math.huge
    local bestPlayer  = nil

    -- Bring these into locals for speed
    local circlePos   = Circle.Position
    local radius      = Circle.Radius
    local pred        = triggerConfig.Prediction
    local velEnabled  = velocityConfig.Enabled
    local velMag      = velocityConfig.Magnitude

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local char = plr.Character
            -- Only loop our small list of part names
            for _, partName in ipairs(allowedPartsList) do
                local part = char:FindFirstChild(partName)
                if part and part.Transparency < 1 then
                    -- apply basic prediction
                    local pos = part.Position
                    if partName == "HumanoidRootPart" then
                        pos = pos + Vector3.new(pred.X, pred.Y, pred.Z)
                        if velEnabled then
                            local v = part.Velocity
                            if v.Magnitude > velMag then
                                pos = pos + v * 0.1
                            end
                        end
                    end

                    -- project to screen
                    local screenPos, onScreen = Camera:WorldToScreenPoint(pos)
                    if onScreen and not WallCheck(part) then
                        local dist = (Vector2.new(screenPos.X, screenPos.Y) - circlePos).Magnitude
                        if dist <= radius and dist < closestDist then
                            closestDist = dist
                            bestPlayer  = plr
                        end
                    end
                end
            end
        end
    end

    return bestPlayer
end

-- Toggle bind (unchanged)
local toggleKey = Enum.KeyCode[ triggerConfig.Activation["Activation Bind"]:upper() ]
UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == toggleKey then
        triggerConfig.Enabled = not triggerConfig.Enabled
    end
end)

-- Main loop, throttled
RunService.Heartbeat:Connect(function(dt)
    timeSinceLast = timeSinceLast + dt
    if timeSinceLast < scanInterval then return end
    timeSinceLast = 0

    if triggerConfig.Enabled then
        local target    = GetPlayerInCircle()
        local aimCursor = LocalPlayer:FindFirstChildOfClass("PlayerGui")
            and LocalPlayer.PlayerGui:FindFirstChild("Aim")  -- or your UI lookup
        if aimCursor then
            Circle.Position = aimCursor.AbsolutePosition
            Circle.Radius   = triggerConfig["FOV"]["X"] * 5
        end

        if target and LocalPlayer.Character then
            local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
            if tool and tool:FindFirstChild("Handle") then
                -- weapon whitelist
                local clean = function(t)
                    return t:lower():gsub("[%[%]%- ]","")
                end
                local toolName = clean(tool.Name)
                local allowed   = false
                for _, w in ipairs(triggerConfig.Weapons) do
                    if toolName:find(clean(w), 1, true) then
                        allowed = true
                        break
                    end
                end

                if allowed and tick() - (LastActivationTime or 0) >= triggerConfig["Click Cooldown"] then
                    tool:Activate()
                    tool:Deactivate()
                    LastActivationTime = tick()
                end
            end
        end
    end
end)

--------------------------------------------------
-- Camera Aimbot (Modified Keybind as String)
--------------------------------------------------
do
    local cameraAimbotConfig = getgenv().Mooze["Camera Aimbot"]
    local globalKeybind = getgenv().Mooze["Global"]["Keybind"] or "E"

    -- pull your key from Global.Keybind:
    cameraAimbotConfig["Keybind"] = globalKeybind

    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local currentCamera = workspace.CurrentCamera

    -- Convert string to KeyCode
    local aimbotKey = Enum.KeyCode[ cameraAimbotConfig["Keybind"]:upper() ]

    local function getTarget()
        local bestTarget = nil
        local shortestDist = math.huge
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local part
                if cameraAimbotConfig["Hit Part"]:lower() == "closest point" then
                    local function getClosestPart(character)
                        local bestPart, bestDist = nil, math.huge
                        local mousePos = UserInputService:GetMouseLocation()
                        for _, p in ipairs(character:GetDescendants()) do
                            if p:IsA("BasePart") then
                                local screenPos, onScreen = currentCamera:WorldToViewportPoint(p.Position)
                                if onScreen then
                                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                                    if dist < bestDist then
                                        bestDist = dist
                                        bestPart = p
                                    end
                                end
                            end
                        end
                        return bestPart
                    end
                    part = getClosestPart(player.Character)
                else
                    part = player.Character:FindFirstChild("HumanoidRootPart")
                end

                if part then
                    local screenPos, onScreen = currentCamera:WorldToViewportPoint(part.Position)
                    if onScreen then
                        local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)).Magnitude
                        if dist < shortestDist then
                            shortestDist = dist
                            bestTarget = part
                        end
                    end
                end
            end
        end
        return bestTarget
    end

    -- toggle on your global key
    UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.KeyCode == aimbotKey then
            cameraAimbotConfig["Enabled"] = not cameraAimbotConfig["Enabled"]
            print("Camera Aimbot is now", cameraAimbotConfig["Enabled"] and "Enabled" or "Disabled")
        end
    end)

    local lastAimbotUpdate = 0
    RunService.RenderStepped:Connect(function(delta)
        lastAimbotUpdate = lastAimbotUpdate + delta

        if cameraAimbotConfig["Enabled"] and lastAimbotUpdate >= 0.05 then
            lastAimbotUpdate = 0
            local targetPart = getTarget()
            if targetPart then
                local pred = Vector3.new(
                    cameraAimbotConfig["Prediction"]["X"],
                    cameraAimbotConfig["Prediction"]["Y"],
                    cameraAimbotConfig["Prediction"]["Z"]
                )
                local targetPos = targetPart.Position + pred
                local newCFrame = CFrame.new(currentCamera.CFrame.Position, targetPos)
                currentCamera.CFrame = currentCamera.CFrame:Lerp(newCFrame, cameraAimbotConfig["Snappiness"])
            end
        end
    end)
end

---------------------------------------------------------
-- Updated Silent Aimbot
---------------------------------------------------------
if not LPH_OBFUSCATED then
	LPH_JIT_MAX = function(...) return (...) end
	LPH_NO_VIRTUALIZE = function(...) return (...) end
end

LPH_JIT_MAX(function()
	local Config = getgenv().Mooze["Silent Aimbot"]
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local LocalPlayer = Players.LocalPlayer
	local Camera = workspace.CurrentCamera
	local Mouse = LocalPlayer:GetMouse()
	local lastMousePos = Vector2.new(0,0)
	local cachedTarget = nil

	-- Modified getClosestPart function that factors in 'Point Scale'
	local function getClosestPart(player)
		local bestPart, bestDist = nil, math.huge
		-- Get the configured point scale
		local pointScale = Config["Closest Point"] and Config["Closest Point"]["Point Scale"] or 1.0
		if player.Character then
			for _, part in pairs(player.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
					if onScreen then
						local partPos = Vector2.new(screenPos.X, screenPos.Y)
						-- Apply the point scale to the measured distance
						local dist = (lastMousePos - partPos).Magnitude * pointScale
						if dist < bestDist then
							bestPart, bestDist = part, dist
						end
					end
				end
			end
		end
		return bestPart
	end

	local FOVCircle = Drawing.new("Circle")
	FOVCircle.Visible = Config["FOV"]["Enabled"]
	FOVCircle.Transparency = 1
	FOVCircle.Thickness = 2
	FOVCircle.NumSides = 100
	FOVCircle.Filled = false

	local function updateFOV()
		lastMousePos = UserInputService:GetMouseLocation()
		local fovConfig = Config["FOV"]
		local currentTool = nil
		if LocalPlayer.Character then
			currentTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
		end
		local radius = fovConfig["Size"].X * 5
		if fovConfig["Weapons Configuration"] and fovConfig["Weapons Configuration"]["Enabled"] and currentTool then
			local weaponName = string.lower(currentTool.Name or "")
			if string.find(weaponName, "shotgun") then
				radius = fovConfig["Weapons Configuration"]["Shotguns"].X * 5
			elseif string.find(weaponName, "pistol") then
				radius = fovConfig["Weapons Configuration"]["Pistols"].X * 5
			end
		end
		FOVCircle.Radius = radius
		FOVCircle.Position = lastMousePos
		local bestPart, bestDist = nil, math.huge
		for _, player in pairs(Players:GetPlayers()) do
			if player ~= LocalPlayer and player.Character then
				local part = nil
				if Config["Hit Part"] == "Closest Point" then
					part = getClosestPart(player)
				else
					part = player.Character:FindFirstChild("Head")
				end
				if part then
					local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
					if onScreen then
						local partPos = Vector2.new(screenPos.X, screenPos.Y)
						local dist = (lastMousePos - partPos).Magnitude
						if dist < bestDist and dist <= radius then
							bestPart, bestDist = part, dist
						end
					end
				end
			end
		end
		cachedTarget = bestPart
	end

	RunService.RenderStepped:Connect(updateFOV)

	local function applyPrediction(cf, offset)
		return cf * CFrame.new(offset.X, offset.Y, offset.Z)
	end

	local mt = getrawmetatable(game)
	setreadonly(mt, false)
	local oldIndex = mt.__index
	mt.__index = newcclosure(function(obj, prop)
		if obj:IsA("Mouse") and (prop == "Hit" or prop == "Target") then
			local target = cachedTarget
			if target then
				local prediction = Config["Prediction"]
				local redir = Config["Client Bullet Redirection"]
				local currentTool = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")) or nil
				if redir["Enabled"] and currentTool then
					local toolName = tostring(currentTool.Name)
					for _, weapon in ipairs(redir["Weapons"]) do
						if string.find(string.lower(toolName), string.lower(weapon)) then
							prediction = redir["Prediction"]
							break
						end
					end
				end
				local predMultiplier = Vector3.new(prediction.X, prediction.Y, prediction.Z)
				local offset = target.Velocity * predMultiplier
				if prop == "Hit" then
					return applyPrediction(target.CFrame, offset)
				else
					return target
				end
			end
		end
		return oldIndex(obj, prop)
	end)

	RunService.Heartbeat:Connect(function()
		if not Config["Enabled"] then return end
		local target = cachedTarget
		local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if target and currentTool and currentTool:FindFirstChild("Activate") then
			currentTool:Activate()
		end
	end)
end)()

-- if not getgenv().directory then
--     game.Players.LocalPlayer:Kick("Script directory was not found!\nNOTE: THE SERVER MAY BE DOWN \nplease dm 1catlol if you have entered yours correctly")
--     wait(3)
--     game.Players.LocalPlayer:Destroy()
--     return LPH_CRASH()
-- end

-- hookfunction security
    local exe_name, exe_version = identifyexecutor()
    local function home999() end
    local function home888() end

    if exe_name ~= "Wave Windows" then
        hookfunction(home888, home999)
        if isfunctionhooked(home888) == false then
            game.Players.LocalPlayer:Destroy()
            return LPH_CRASH()
        end
    end 
    
    local function check_env(env)
        for _, func in env do
            if type(func) ~= "function" then
                continue
            end

            local functionhook = isfunctionhooked(func)

            if functionhook then
                game.Players.LocalPlayer:Destroy()
                return LPH_CRASH()
            end
        end
    end

    check_env( getgenv() )
    check_env( getrenv() )
--

local Lua_Fetch_Connections = getconnections
local Lua_Fetch_Upvalues = getupvalues
local Lua_Hook = hookfunction 
local Lua_Hook_Method = hookmetamethod
local Lua_Unhook = restorefunction
local Lua_Replace_Function = replaceclosure
local Lua_Set_Upvalue = setupvalue
local Lua_Clone_Function = clonefunction

local Game_RunService = game:GetService("RunService")
local Game_LogService = game:GetService("LogService")
local Game_LogService_MessageOut = Game_LogService.MessageOut

local String_Lower = string.lower
local Table_Find = table.find
local Get_Type = type

local Current_Connections = {};
local Hooked_Connections = {};

local function Test_Table(Table, Return_Type)
    for TABLE_INDEX, TABLE_VALUE in Table do
        if type(TABLE_VALUE) == String_Lower(Return_Type) then
            return TABLE_VALUE, TABLE_INDEX
        end

        continue
    end
end

local function Print_Table(Table)
    table.foreach(Table, print)
end

if getgenv().DEBUG then
    print("[auth.injected.live] Waiting...")
end

local good_check = 0

function auth_heart()
    -- local avalible = pcall(function() return loadstring(game:HttpGet("https://auth.injected.live/" .. directory))() end)
    
    -- if (not avalible or not game:HttpGet("https://auth.injected.live/" .. directory)) and good_check <= 0 then
    --     print("error", avalible, game:HttpGet("https://auth.injected.live/" .. directory))
    --     game.Players.LocalPlayer:Destroy()
    --     return LPH_CRASH()
    -- end

    return true , true
end

function Lua_Common_Intercept(old, ...)
    print(...)
    return old(...)
end

function XVNP_L(CONNECTION)
    local s, e = pcall(function()
        local OPENAC_TABLE = Lua_Fetch_Upvalues(CONNECTION.Function)[9]
        local OPENAC_FUNCTION = OPENAC_TABLE[1]
        local IGNORED_INDEX = {3, 12, 1, 11, 15, 8, 20, 18, 22}

        --[[
            3(Getfenv), 1(create thread), 12(Some thread function errors btw), 11( buffer (BANS YOU) ), 8(BXOR), 14(WRAP), 15(YIELD), 22(JUNK), 20(Setfenv), 18(Idk for now)
        ]]


        Lua_Set_Upvalue(OPENAC_FUNCTION, 14, function(...)
            return function(...)
                local args = {...}

                if type(args[1]) == "table" and args[1][1] then
                    pcall(function()
                        if type(args[1][1]) == "userdata" then
                            args[1][1]:Disconnect()
                            args[1][2]:Disconnect()
                            args[1][3]:Disconnect()
                            args[1][4]:Disconnect()
                            --warn("[XVNP] DISCONNECTING CURRENT FUNCTIONS")
                        end

                        --Print_Table(args[1])
                    end)
                end 
            end
        end)

        Lua_Set_Upvalue(OPENAC_FUNCTION, 1, function(...)
            task.wait(200)
        end)

        hookfunction(OPENAC_FUNCTION, function(...)
            --warn("[XVNP DEBUG]", ...)
            return {}
        end)
    end)
end

local XVNP_LASTUPDATE = 0
local XVNP_UPDATEINTERVAL = 5

local XVNP_CONNECTIONSNIFFER;

XVNP_CONNECTIONSNIFFER = Game_RunService.RenderStepped:Connect(function()
    if #Lua_Fetch_Connections(Game_LogService_MessageOut) >= 2 then
        --print("[XVNP] !Emulator overflow!")
        XVNP_CONNECTIONSNIFFER:Disconnect()
    end

    if tick() - XVNP_LASTUPDATE >= XVNP_UPDATEINTERVAL then
        XVNP_LASTUPDATE = tick() 

        local OpenAc_Connections = Lua_Fetch_Connections(Game_LogService_MessageOut)

        for _, CONNECTION in OpenAc_Connections do
            if not table.find(Current_Connections, CONNECTION) then
                table.insert(Current_Connections, CONNECTION)
                table.insert(Hooked_Connections, CONNECTION)

                XVNP_L(CONNECTION)
                
            end
        end
    end
end)

local last_beat = 0
Game_RunService.RenderStepped:Connect(function()
    if last_beat + 1 < tick() then
        last_beat = tick() + 1 

        local what, are = auth_heart()

        if not are or not what then
            if good_check <= 0 then
                game.Players.LocalPlayer:Destroy()
                return LPH_CRASH()
            else
                good_check -=1
            end
        else
            good_check += 1
        end

    end
end)

if getgenv().DEBUG then
    print("[auth.injected.live] Started Emulation Thread")
end

-----------------------------------
-- Slowdown Modification 
-----------------------------------
local is_firing = false
local utility = {}

utility.get_gun = function()
    for _, tool in next, game.Players.LocalPlayer.Character:GetChildren() do
        if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
            return tool
        end
    end
end

utility.rapid = function(tool)
    tool:Activate()
end

game:GetService("UserInputService").InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        local gun = utility.get_gun()
        if gun and not is_firing then
            is_firing = true
            local gunName = gun.Name
            local multiplier = 1
            local slowdownConfig = getgenv().Mooze["Movement Modifications"]["Slowdown Modifications"]
            if slowdownConfig and slowdownConfig["Enabled"] then
                local weaponConfig = slowdownConfig["Weapons"][gunName]
                if weaponConfig then
                    multiplier = weaponConfig["Multiplier"] or 1
                end
            end
            local fireRateDelay = multiplier
            print("Firing with delay:", fireRateDelay)
            while is_firing do
                utility.rapid(gun)
                task.wait(fireRateDelay)
            end
        end
    end
end)

game:GetService("UserInputService").InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        is_firing = false
    end
end)

--------------------
-- spread mod
-------------------
local Players = game:GetService("Players")
local player  = Players.LocalPlayer

-- grab the spread settings straight out of Mooze
local spreadConfig = getgenv().Mooze
                     and getgenv().Mooze['Weapon Modifications']
                     and getgenv().Mooze['Weapon Modifications']['Spread Modifications']

local originalHorizontal = 0.1
local originalVertical   = 0.1

local function normalize(s)
    return tostring(s):lower():gsub("%W", "")
end

local function log(...)
    -- print(...)
end

local function applySpread()
    if not spreadConfig or not spreadConfig.Enabled then
        return
    end

    for weaponKey, settings in pairs(spreadConfig) do
        if weaponKey ~= "Enabled" and type(settings) == "table" then
            local mult    = settings.Multiplier
            local hSpread = originalHorizontal * mult
            local vSpread = originalVertical   * mult
            local keyNorm = normalize(weaponKey)

            for _, fn in ipairs(getgc(true)) do
                if type(fn) == "function"
                and islclosure(fn)
                and not isexecutorclosure(fn)
                then
                    local info = debug.getinfo(fn)
                    if info and info.short_src then
                        local srcNorm = normalize(info.short_src)
                        if srcNorm:find(keyNorm, 1, true) then
                            log("Patching", weaponKey, "in", info.short_src)
                            for idx, const in ipairs(debug.getconstants(fn)) do
                                if type(const) == "number" then
                                    -- horizs: (0,0.1) | verts: [0.1,0.3)
                                    if const > 0   and const < 0.1 then
                                        debug.setconstant(fn, idx, hSpread)
                                        log(" → horiz const #"..idx.." →", hSpread)
                                    elseif const >= 0.1 and const < 0.3 then
                                        debug.setconstant(fn, idx, vSpread)
                                        log(" → vert const #"..idx.." →", vSpread)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

-- apply once now…
applySpread()

-- …and again on spawn/respawn
if player.Character then
    applySpread()
end
player.CharacterAdded:Connect(function()
    task.wait(1)
    applySpread()
end)


-----------------------------
-- Speed Modification 
-----------------------------------
-- Check if Mooze and SpeedConfig are valid
if not getgenv().Mooze 
    or type(getgenv().Mooze) ~= "table" 
    or not getgenv().Mooze["Movement Modifications"] 
    or not getgenv().Mooze["Movement Modifications"]["Speed Modifications"] 
    or not getgenv().Mooze["Movement Modifications"]["Speed Modifications"].Enabled 
then
    return
end

local Mooze = getgenv().Mooze
local SpeedConfig = Mooze["Movement Modifications"]["Speed Modifications"]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- Initial setup
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid") or character:WaitForChild("Humanoid")

-- Flags for state tracking
local isShooting = false
local isReloading = false
local LOW_HEALTH_THRESHOLD = 50

-- Shooting detection
local mouse = player:GetMouse()
mouse.Button1Down:Connect(function()
    isShooting = true
end)
mouse.Button1Up:Connect(function()
    isShooting = false
end)

-- Reloading detection
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.R and not isReloading then
        isReloading = true
        task.delay(1, function()
            isReloading = false
        end)
    end
end)

-- Update character and humanoid references on respawn
player.CharacterAdded:Connect(function(char)
    character = char
    humanoid = nil -- reset before waiting
    humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
end)

-- Main loop to modify WalkSpeed
RunService.RenderStepped:Connect(function()
    if not SpeedConfig.Enabled then return end
    if not humanoid or humanoid.Health <= 0 then return end

    local speed = SpeedConfig.Normal and SpeedConfig.Normal.Multiplier or humanoid.WalkSpeed

    if humanoid.Health < LOW_HEALTH_THRESHOLD and SpeedConfig["Low Health"] then
        speed = SpeedConfig["Low Health"].Multiplier
    elseif isReloading and SpeedConfig.Reloading then
        speed = SpeedConfig.Reloading.Multiplier
    elseif isShooting and SpeedConfig.Shooting then
        speed = SpeedConfig.Shooting.Multiplier
    end

    if humanoid.WalkSpeed ~= speed then
        humanoid.WalkSpeed = speed
    end
end)
